# Eilend grammar


stmt ::=

  type_stmt |

  "{" stmt {stmt} "}" |

  "while" exp stmt |

  "repeat" stmt {stmt} "until" exp |

  "if" exp stmt {"else" "if" exp stmt} ["else" stmt] |
  
  "for" NAME "=" exp "..." exp ["," "step" exp] stmt |

  "for" namelist "in" explist stmt |

  "function" funcname "(" [typed_parlist] ")" stmt |

  "local" "function" NAME "(" [parlist] ")" stmt |

  varlist "=" explist |

  "local" namelist ["=" explist] |

  "return" [expr] |

  "break" |

  expr


varlist ::= var {"," var}

var ::= NAME { "." NAME } ["::" type_expr]

namelist ::= NAME { "," NAME }
namelist ::= NAME "::" type_expr {"," NAME "::" type_expr}

funcname ::= NAME {"." NAME} [":" NAME]

explist ::= {exp ","} exp

parlist ::= namelist ["," "..."] | "..."
typed_parlist ::= typed_namelist ["," "..." "::" type_expr] | "..." "::" type_expr


expr ::= disj

disj ::=
    conj { "or" cmp }

conj ::=
    cmp { "and" cmp }

cmp ::=
    term {
    ">" term |
    "<" term |
    "<=" term |
    ">=" term |
    "==" term |
    "!=" term
    }

term ::=
    factor {
    "+" factor |
    "-" factor
    }

factor ::=
    unop {
    "*" unop |
    "/" unop |
    "%" unop
    }

unop ::=
    "-" unop |
    "not" unop |
    "len" unop |
    call

call ::=
    primary {
    "(" [expr] {"," expr} ")" |
    ":" NAME "(" [expr] {"," expr} ")" |  # match ":" even on next line
    "." NAME |  # match "." even on next line
    "[" expr "]" |
    tableconstructor |
    STRING
    }

primary ::=
  "nil" |
  "false" |
  "true" |
  NUMBER |
  STRING |
  "..." |

  "->" stmt |
  NAME "->" stmt |
  "(" [parlist] ")" "->" stmt |
  "(" expr ")" |

  tableconstructor |
  NAME


tableconstructor ::= "{" [fieldlist] "}"

fieldlist ::= field {"," field} [","]

field ::= "[" exp "]" ["::" type_expr] "=" exp | NAME ["::" type_expr] "=" exp | exp


type_stmt ::=
    type_alias

type_alias ::=
    "type" NAME [ "(" NAME { "," NAME } ")" ] "=" type_expr

type_expr ::=
    type_disj

type_disj ::=
    type_conj { "|" type_conj }

type_conj ::=
    type_unary { "&" type_unary }

type_unary ::=
    "~" type_morph |
    type_morph

type_morph ::=
    type_primary {
    "(" type_expr ")"
    }

type_primary ::=
    NAME |
    "(" type_expr { "," type_expr } ")" "->" type_expr |
    type_table

type_table ::=
    "{" NAME "::" type_expr { "," NAME "::" type_expr } "}"

